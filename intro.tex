\section{Introduction}
\label{sec:intro}

Software libraries play an important role in software
development. Their functionality is provided via Application
Programming Interface (API) elements including classes, methods, and
fields. Developers should follow the usage documentation of software
libraries to use the API elements in a specific combination to
accomplish certain programming tasks. Such usages are called {\em API
  usages}. The frequently occurring API usages are called~{\em
  API~usage patterns}. Several approaches have been leveraging API
usages and/or patterns to support software engineering tasks such as
pattern-based code completion~\cite{icse12}, API method
completion~\cite{fse16}, API usage recommendation~\cite{icsme18}, API
code migration~\cite{ase14}, fully-qualified name
suggestion~\cite{icse18}, API documentation
suggestion~\cite{liveapi14}, etc.

To use API elements correctly, developers could rely on API
documentation or online forums, e.g., StackOverflow (S/O) or GitHub
Gists. Unfortunately, due to the context of the ongoing discussions in
such forums, the code snippets in the answering S/O posts may contain
the ambiguities on the references to the API elements of the external
libraries~\cite{liveapi14}.

Several approaches have been proposed to automatically resolve the
fully qualified names (FQNs) of the API elements for a code
snippet. They can be classified into the following categories. The
first category is {\em program analysis}. Partial~program
analysis~\cite{dagenais-oopsla08} derives the types/FQNs by analyzing
the relations among program elements in a best-effort
manner. RecoDoc~\cite{dagenais-icse12} utilizes several heuristics on
syntactic constructs to recognize the names. The key issue with
best-effort analysis and heuristics is that they might not work in all
the cases. The second category is {\em information retrieval}
(IR). Baker~\cite{liveapi14} builds a candidate list for each name by
tracking the scopes of the names and then overlapping the lists
according to the scoping rules for short-listing.
COSTER~\cite{coster-ase19} captures the context of the query API
element and matches that with the FQNs of API elements with three
criteria on likelihood, context similarity, and name similarity.  The
third category is {\em constraint-based}. SnR~\cite{snr-icse22} builds
a knowledge base of APIs, i.e., various facts about the available
APIs. SnR extracts typing constraints from the given snippet, and
solves the constraints against the knowledge base. The key limitation
with the IR and constraint-based approaches is that the dictionary of
the APIs must be known a priori, thus, they cannot deal with the FQNs
that have not been seen before in the training corpus.

To address that, a few approaches have leveraged {\em artificial
  intelligence (AI) and machine learning (ML)} in deriving
FQNs. StatType~\cite{icse18} formulates the problem of FQN resolution
as the {\em phrase-based machine translation} from the code without
FQNs to the one with them. The key issue is that with
its~short phrases of code tokens, StatType does not capture well the
relations of the APIs in the surrounding context, which is useful
in deciding the FQNs from the simple names of the API elements.
%
Huang {\em et al.}~\cite{prompt-ase22} formulates this problem as a
filling-in-a-blank task with an FQN using a masked language model.
It collects as a training instance a code snippet consisting
of one simple name for an API element and a couple lines before and
after that name. Thus, if those surrounding lines do not contain any
API names, the model could not take advantage of the relations among
the API elements to derive their FQNs. In other words, while using the
context of a few lines, it does not leverage the {\bf dependency
  context} among the API elements for FQN prediction. In fact, the
dependency context can provide crucial hints for deriving FQNs. Let us
take an example in Google Web Toolkit (GWT). 
\begin{lstlisting}[
frame=shadowbox,
rulesepcolor= \color{red!20!green!20!blue!20} ,
xleftmargin=1.5em,xrightmargin=0em, aboveskip=1em,
framexleftmargin=1.5em,
numbersep= 5pt,
language=Java,
basicstyle=\scriptsize\ttfamily, numberstyle=\scriptsize\ttfamily, emphstyle=\bfseries, escapeinside= {(*@}{@*)}]
{
  StyleElement style=Document.get().createStyleElement();
  cssRes = resources.(*@{\color{blue}css();@*)
  ...
  s = cssRes.(*@{\color{blue}getText();@*)
  ...
  style.(*@{\color{blue}setInnerText(s);@*)
  ...
}                
\end{lstlisting}
%Need a small example
%Take as an example a code snippet (not shown) in our dataset with the
%presence of \code{getText}. This name is popular with a very large
%number of API method candidates. However, considering the relation
%between \code{css} and \code{getText} in the code
%\code{`...css()\-.getText()'},~the number of candidates for
%\code{getText} is only 4. Finally, considering~the return value of
%\code{getText} as an argument of \code{setInnerText(...)} in the code
%\code{`setInnerText(...css()\-.getText())'}, only one candidate is
%remained:
%\code{com\-.google\-.gwt\-.resources\-.client\-.CssResource\-.getText()}.
%Thus, those relations actually help identify the API elements,
The code snippet is inspired from the S/O post \#34595450.  Let us
consider the method call \code{getText} at line 5, which is a very
popular API name in different libraries. Nguyen {\em et
  al.}~\cite{icse18} reported that there are about 500 API methods of
that name in five different Java libraries. Considering the data
dependency between the statements at line 3 and at line 5 via the
variable \code{cssRes}, we can see that the return type of
\code{css(...)} has a member API method of the name \code{getText}.
With that knowledge, the number of candidates for \code{getText} is
down to 4. Now, considering the data dependency between the statements
at line 5 and line 7 via the variable \code{s}, we can see that the
API method \code{setInnerText} accepts as the first argument a
variable of the type compatible with the return type of \code{getText}
at line 5. With that knowledge, there is only one single candidate for
\code{getText} at line 5, which is
\code{com\-.google\-.gwt\-.resources\-.client\-.CssResource\-.getText()}.
In brief, the relations among the API names help identify the
corresponding API elements. The state-of-the-art ML approach, Huang
{\em et al.}~\cite{prompt-ase22}, breaks the code snippet into
multiple pieces, each contains one API method call, e.g., the lines
4-6 are used to predict the FQN of \code{getText} at line 5, thus,
cannot leverage the dependency context in this.

%Tien
We introduce {\tool}, an ML-based approach to recover the FQNs for all
the APIs in any code snippet.
%Instead of characterizing the context with a few lines before and
%after the location of an API element to derive its FQN,
we leverage the dependencies among the API elements in
API usages to decide the FQNs for all the relevant APIs at once. We
consider the FQNs as the identities of the API elements and we follow
the philosophy {\em ``Tell Me Your Friends, I'll Tell You Who You
  Are''} to derive the FQNs. To determine the ``friends'' of an API
element $A$, we leverage the program entities and other API elements
that depend on and/or have relations with $A$. The software library
designers always have the intents for users to use certain API
elements together in the specific combinations/orders to achieve a
programming task. Such combinations of API elements are often referred
to as {\em API usages}. Therefore, such API elements in API usages
frequently occur together in the code using the libraries, which are
referred to as {\em API usage patterns}.

That {\em basis of regularity of API usages} drives our approach in
two ways. First, the API elements with their FQNs regularly appear
together in API usages have higher impact in deciding the FQNs than
the less regular ones. Thus, a ML model could {\em learn such
  regularly co-appearing API elements from a training corpus to help
  derive their FQNs at once}. We leverage the complete, compilable
code from the open-source code repositories using the libraries in
which the FQNs of all the API elements are available. Second, {\em the
  program dependencies and usage relations among API elements are
  useful in deriving their identities (i.e., FQNs)}. For example, in
the following two statements: \code{Button b = new Button(``OK'');}
\code{b\-.addClickHandler\-(\-new ClickHandler\-())}. The class name
\code{Button} is very popular across several libraries (e.g.,
\code{Button} appears in both Google Web Toolkit (GWT) and
\code{Android} library). Relying solely on the first statement might
not be sufficiently to derive the FQNs for the API elements
\code{Button}, \code{addClickHandler}, and \code{ClickHandler}, and
the variable \code{b}. However, the \code{def-use} dependency between
two statements via the variable \code{b} could give a model a hint on
the FQNs of all the elements.  If a model learns in the training
corpus that a GWT \code{Button} can be a receiving object of a method
call \code{addClickHandler}, which in turn accepts as the
argument an object of the type \code{ClickHandler}, it will be able to
derive the FQNs for the elements in both statements at once.

Putting together those ideas, we design {\tool}, ...

We performed several experiments to evaluate {\tool}. ...

The key contributions of this paper include:

1. {\tool}: a neural-network approach ...


2. An extensive evaluation showing {\tool}'s better accuracy in
deriving FQNs than the state-of-the-art approaches.

3. An analysis showing the embeddings for the API elements ...

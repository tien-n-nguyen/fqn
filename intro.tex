\section{Introduction}
\label{sec:intro}

Software libraries and frameworks play important roles in software
development. Their functionality is provided via the Application
Programming Interface (API) elements including classes, methods, and
fields. The online forums, e.g., StackOverflow or GitHub Gists, have
provided an excellent resource on how to use API
elements. Unfortunately, due to the current context of the discussions
in such forums, the code snippets in the answering StackOverflow posts
may contain the ambiguities on the references to the API elements of
the external libraries~\cite{liveapi14}.

Several approaches have been proposed to automatically resolve the
fully qualified names (FQNs) of the API elements for the code snippets
in the public forums.  The approaches can be classified into different
categories. The first category is {\em program analysis}. Partial
program analysis~\cite{dagenais-oopsla08} derives the types and FQNs
in a best-effort manner. RecoDoc~\cite{dagenais-icse12} utilizes
several heuristics on syntactic constructs to recognize the names.
The second category is {\em information
  retrieval}. Baker~\cite{liveapi14} builds a candidate list for each
name by tracking the scopes of the names and then overlapping the
lists according to the scoping rules to narrow down the candidates.
COSTER~\cite{coster-ase19} captures the context of the query API
element and matches that with the FQNs of API elements with three
criteria on likelihood, context similarity, and name similarity.  The
third category is {\em constraint-based}.  SnR~\cite{snr-icse22}
builds a knowledge base of APIs, i.e., various facts about the
available APIs.  SnR extracts typing constraints from the given
snippet, and solves the constraints against the knowledge base. The
fourth category leverages the advances in {\em artificial intelligence
  (AI) and machine learning (ML)}. StatType considers the problem of
deriving FQNs as the machine translation from the code without FQNs to
the one with them. Huang {\em et al.}~\cite{prompt-ase22} formulate
the problem as a fill-in-blank task using a masked language model. The
approach fills in the FQN for each name considering the context
consisting of the few lines before and after the fill-in location.
The key issue is that the API elements are designed to use in
different client code, making the surrounding contexts different for
different code using the APIs.

Instead of characterizing the surrounding context of the location of
an API element to derive its FQN, we leverage the dependencies and
relations among the API elements in API usages to decide the FQNs at
once. We consider the FQNs as the identities of the API elements and
we follow the philosophy {\em ``Tell Me Your Friends, I'll Tell You
  Who You Are''} to derive the FQNs. To determine the ``friends'' of
an API element $A$, we leverage the program entities and other API
elements that depend and/or have relations with $A$. The software
library designers always have the intents for users to use certain API
elements together in the specific combinations/orders to achieve some
programming tasks, which are often referred to as {\em API
  usages}. Therefore, such API elements in API usages frequently occur
together in the code using the libraries, which are referred to as
{\em API usage patterns}. Such basis of regularity of API usages
drives our model in two ways. First, the API elements with their FQNs
regularly appear together in API usages have higher impact in deciding
the FQNs than the less regular ones. Thus, a ML model could learn such
regularly co-appearing API elements from a training corpus to help
derive their FQNs at once. We leverage the complete, compilable code
using the libraries from open-source code repositories in which the
FQNs of all the API elements are known. Second, ...
